ln + (0-06+0.5*0.4^2)
(ln + (0-06+0.5*0.4^2))/0.4
lb
ln
(ln + (0.06+0.5*0.4^2))/0.4
pnorm(0.228)
pnorm(-0.172)
pnorm(0.172)
1-pnorm(0.172)
100*0.5910
100*exp(0.06)
ln <- log(100/105*exp(-0.06))
(ln+0.5*0.4^2)/0.4
pnorm(-0.071975)
-0.07197541-0.4
pnorm(-0.4719)
105exp(0.06)*0.318
105*exp(0.06)*0.318
105*exp(-0.06)*0.318
47.13-31.44
library(ggplot2)
library(ggplot2)
ln <- log(106/105*exp(-0.06))
btc_hist %>%
ggplot(aes(x = timestamp, y = open)) +
geom_line() +
geom_point(data = . %>% filter(tweet == TRUE), color = "deeppink", size = 3)
library(ggplot2)
library(dplyr)
btc_hist %>%
ggplot(aes(x = timestamp, y = open)) +
geom_line() +
geom_point(data = . %>% filter(tweet == TRUE), color = "deeppink", size = 3)
# load the data set and summarize the included variables
redwines <- readr::read_csv("https://www.warin.ca/datalake/courses_data/qmibr/session8/redwines.csv")
# load the data set and summarize the included variables
redwines <- readr::read_csv("redwines.csv")
redwines <- read.csv("~/Desktop/MONTREAL/QM/redwines.csv")
View(redwines)
summary(redwines)
m1 <- glm(good ~ fixed.acidity + volatile.acidity + residual.sugar + chlorides + total.sulfur.dioxide + density + sulphates + alcohol, data = redwines, family = "binomial")
head(redwines$good, 20)
library(tidyverse)
redwines <- redwines %>% mutate(good = case_when(good == "Yes" ~ 1
, TRUE ~ 0))
redwines$good <- as.factor(redwines$good)
library(cowplot)
library(gridExtra)
install.packages("cowplot")
installed.packages("gridExtra")
p1 <- ggplot(redwines, aes(x = good, y = fixed.acidity)) +   geom_boxplot()
p2 <- ggplot(redwines, aes(x = good, y = volatile.acidity)) +   geom_boxplot()
p3 <- ggplot(redwines, aes(x = good, y = residual.sugar)) +   geom_boxplot()
p4 <- ggplot(redwines, aes(x = good, y = chlorides)) +   geom_boxplot()
p5 <- ggplot(redwines, aes(x = good, y = total.sulfur.dioxide)) +   geom_boxplot()
p6 <- ggplot(redwines, aes(x = good, y = density)) +   geom_boxplot()
p7 <- ggplot(redwines, aes(x = good, y = sulphates)) +   geom_boxplot()
p8 <- ggplot(redwines, aes(x = good, y = alcohol)) +   geom_boxplot()
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, nrow = 2)
library(cowplot)
library(gridExtra)
install.packages("gridExtra")
p1 <- ggplot(redwines, aes(x = good, y = fixed.acidity)) +   geom_boxplot()
p2 <- ggplot(redwines, aes(x = good, y = volatile.acidity)) +   geom_boxplot()
p3 <- ggplot(redwines, aes(x = good, y = residual.sugar)) +   geom_boxplot()
p4 <- ggplot(redwines, aes(x = good, y = chlorides)) +   geom_boxplot()
p5 <- ggplot(redwines, aes(x = good, y = total.sulfur.dioxide)) +   geom_boxplot()
p6 <- ggplot(redwines, aes(x = good, y = density)) +   geom_boxplot()
p7 <- ggplot(redwines, aes(x = good, y = sulphates)) +   geom_boxplot()
p8 <- ggplot(redwines, aes(x = good, y = alcohol)) +   geom_boxplot()
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, nrow = 2)
library(gridExtra)
p1 <- ggplot(redwines, aes(x = good, y = fixed.acidity)) +   geom_boxplot()
p2 <- ggplot(redwines, aes(x = good, y = volatile.acidity)) +   geom_boxplot()
p3 <- ggplot(redwines, aes(x = good, y = residual.sugar)) +   geom_boxplot()
p4 <- ggplot(redwines, aes(x = good, y = chlorides)) +   geom_boxplot()
p5 <- ggplot(redwines, aes(x = good, y = total.sulfur.dioxide)) +   geom_boxplot()
p6 <- ggplot(redwines, aes(x = good, y = density)) +   geom_boxplot()
p7 <- ggplot(redwines, aes(x = good, y = sulphates)) +   geom_boxplot()
p8 <- ggplot(redwines, aes(x = good, y = alcohol)) +   geom_boxplot()
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, nrow = 2)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, nrow = 2)
summary(m1)
m1 <- glm(good ~ fixed.acidity + volatile.acidity + residual.sugar + chlorides + total.sulfur.dioxide + density + sulphates + alcohol, data = redwines, family = "binomial")
summary(m1)
# Odds ratios only
exp(coef(m1))
# Let us keep everything constant but our predictor
newm1 <- with(redwines, data.frame(alcohol = 8:15, fixed.acidity  = mean(fixed.acidity, na.rm = TRUE), volatile.acidity = mean(volatile.acidity, na.rm=TRUE), residual.sugar = mean(residual.sugar, na.rm = TRUE), chlorides = mean(chlorides, na.rm = TRUE), total.sulfur.dioxide = mean(total.sulfur.dioxide, na.rm = TRUE), density = mean(density, na.rm = TRUE), sulphates = mean(sulphates, na.rm = TRUE)))
# let us create the predicted probabilities
preds <- predict(m1, newm1, type = "response", se.fit=TRUE)
preds$fit
# Let us keep everything constant but our predictor
newm1 <- with(redwines, data.frame(alcohol = 8:17, fixed.acidity  = mean(fixed.acidity, na.rm = TRUE), volatile.acidity = mean(volatile.acidity, na.rm=TRUE), residual.sugar = mean(residual.sugar, na.rm = TRUE), chlorides = mean(chlorides, na.rm = TRUE), total.sulfur.dioxide = mean(total.sulfur.dioxide, na.rm = TRUE), density = mean(density, na.rm = TRUE), sulphates = mean(sulphates, na.rm = TRUE)))
# let us create the predicted probabilities
preds <- predict(m1, newm1, type = "response", se.fit=TRUE)
preds$fit
View(redwines)
mean(redwines$alcohol)
count(redwines$alcohol > 15)
# Let us keep everything constant but our predictor
newm1 <- with(redwines, data.frame(alcohol = 8:15, fixed.acidity  = mean(fixed.acidity, na.rm = TRUE), volatile.acidity = mean(volatile.acidity, na.rm=TRUE), residual.sugar = mean(residual.sugar, na.rm = TRUE), chlorides = mean(chlorides, na.rm = TRUE), total.sulfur.dioxide = mean(total.sulfur.dioxide, na.rm = TRUE), density = mean(density, na.rm = TRUE), sulphates = mean(sulphates, na.rm = TRUE)))
# let us create the predicted probabilities
preds <- predict(m1, newm1, type = "response", se.fit=TRUE)
# Let us use the SE for a beautiful graph
predf <- preds$fit # predicted
lower <- preds$fit - (1.96*preds$se.fit) # lower bounds
upper <- preds$fit + (1.96*preds$se.fit) # upper bounds
# Let's plot now
plot(8:15, predf, type="l", ylab="Predicted Probability to be Good", xlab="Alcohol", bty="n")
lines(8:15, lower, lty=2)
lines(8:15, upper, lty=2)
loans$default = loans$not.fully.paid
lines(550:900, p, col = "blue", lwd = 3 )
plot(loans$fico, loans$default)
p = predict(m2, newdata = data.frame(fico=550:900), type = "response")
lines(550:900, p, col = "blue", lwd = 3 )
m2 <- glm(default ~ fico, data = loans, family = "binomial")
p = predict(m2, newdata = data.frame(fico=550:900), type = "response")
lines(550:900, p, col = "blue", lwd = 3 )
summary(loans.glmfull)
# perform a backward stepwise model selection to build a best predictive model
loans.glmfull = glm(default ~ fico + dti + log.annual.inc + int.rate + purpose, family = "binomial", data = loans)
summary(loans.glmfull)
summary(loans.glmfull)
loans.glmfull = glm(default ~ fico + dti + log.annual.inc + int.rate + purpose, family = "binomial", data = loans)
summary(loans.glmfull)
loans.glm.step <- step(loans.glmfull)
# load the data set and summarize the included variables
summary(redwines)
redwines <- redwines %>% mutate(good = case_when(good == "Yes" ~ 1
, TRUE ~ 0))
redwines$good <- as.factor(redwines$good)
exercise <- glm(good ~ alcohol, data = redwines, family = "binomial")
m1 <- lm(good ~ fixed.acidity + volatile.acidity + residual.sugar + chlorides + total.sulfur.dioxide + density + sulphates + alcohol, data = redwines, family = "binomial")
exercise <- lm(good ~ alcohol, data = redwines, family = "binomial")
exercise <- lm(good ~ alcohol, data = redwines)
redwines$good <- as.factor(redwines$good)
redwines <- redwines %>% mutate(good = case_when(good == "Yes" ~ 1
, TRUE ~ 0))
redwines$good <- as.factor(redwines$good)
exercise <- glm(good ~ alcohol, data = redwines, family = "binomial")
summary(exercise)
# Let us keep everything constant but our predictor
newm1 <- with(redwines, data.frame(alcohol = 8:17, fixed.acidity  = mean(fixed.acidity, na.rm = TRUE), volatile.acidity = mean(volatile.acidity, na.rm=TRUE), residual.sugar = mean(residual.sugar, na.rm = TRUE), chlorides = mean(chlorides, na.rm = TRUE), total.sulfur.dioxide = mean(total.sulfur.dioxide, na.rm = TRUE), density = mean(density, na.rm = TRUE), sulphates = mean(sulphates, na.rm = TRUE)))
# let us create the predicted probabilities
preds <- predict(m1, newm1, type = "response", se.fit=TRUE)
preds$fit
# Let us keep everything constant but our predictor
newm1 <- with(redwines, data.frame(alcohol = 8:17, fixed.acidity  = mean(fixed.acidity, na.rm = TRUE), volatile.acidity = mean(volatile.acidity, na.rm=TRUE), residual.sugar = mean(residual.sugar, na.rm = TRUE), chlorides = mean(chlorides, na.rm = TRUE), total.sulfur.dioxide = mean(total.sulfur.dioxide, na.rm = TRUE), density = mean(density, na.rm = TRUE), sulphates = mean(sulphates, na.rm = TRUE)))
# let us create the predicted probabilities
preds <- predict(m1, newm1, type = "response", se.fit=TRUE)
preds$fit
# Create the mydata1 dataframe
mydata1 <- readr::read_csv("https://warin.ca/datalake/courses_data/qmibr/22128714/mydata1.csv")
mydata1 <- read.csv("~/Desktop/MONTREAL/QM/mydata1.csv")
View(mydata1)
# uncomment (=remove the hashtag) to view your dataframe
View(mydata1)
colnames(mydata1)
# Get the column names
colnames(mydata1)
# boxplot
library(ggplot)
# boxplot
library(ggplot2)
ggplot(mydata1, aes(x = party, y = voteshare)) +   geom_boxplot()
# Distribution of our dependent variable
ggplot(mydata1, aes(x=voteshare)) + geom_histogram()
# Define IQR and compute it for our dependent variable
IQR(mydata1$voteshare)
# Define IQR and compute it for our dependent variable
IQR(mydata1$voteshare)
# Code
skewness(mydata1$voteshare)
# Code
library(e1071)
skewness(mydata1$voteshare)
install.packages("e1071")
# Code
library(e1071)
skewness(mydata1$voteshare)
# Code
kurtosis(voteshare)
# Code
kurtosis(mydata1$voteshare)
View(mydata1)
mean(mydata1$party == "regionalist")
max(mydata1$party == "regionalist")
mydata1 %>% filter(mydata1$party == "regionalist")
mydata1 %>% filter(mydata1$party == "regionalist") %>% mean()
mydata1 %>% filter(party == "regionalist") %>% mean(voteshare)
regionalist <- mydata1 %>% filter(party == "regionalist")
mean(regionalist$voteshare)
mydata1 %>% group_by(party)
regionalist <- mydata1 %>% filter(party == "regionalist")
mean(region)
mean(regionalist$voteshare)
View(regionalist)
#also obtainable by subtracting the third quantile to the first quantile
(quantile(mydata1$voteshare), prob=.75) - (quantile(mydata1$voteshare), prob=.25)
#also obtainable by subtracting the third quantile to the first quantile
(quantile(mydata1$voteshare, prob=.75) - (quantile(mydata1$voteshare, prob=.25)
#also obtainable by subtracting the third quantile to the first quantile
quantile(mydata1$voteshare, prob=.75) - (quantile(mydata1$voteshare, prob=.25)
#also obtainable by subtracting the third quantile to the first quantile
quantile(mydata1$voteshare, prob=.75) - (quantile(mydata1$voteshare, prob=.25)
#also obtainable by subtracting the third quantile to the first quantile
quantile(mydata1$voteshare, prob=.75) - quantile(mydata1$voteshare, prob=.25)
#also obtainable by subtracting the third quantile to the first quantile
quantile(mydata1$voteshare, prob=.75) - quantile(mydata1$voteshare, prob=.25)
# Define IQR and compute it for our dependent variable
IQR(mydata1$voteshare)
#also obtainable by subtracting the third quantile to the first quantile
quantile(mydata1$voteshare, prob=.75) - quantile(mydata1$voteshare, prob=.25)
m1 <- lm(mydata1$voteshare ~ mydata1$emigration + mydata1$immigration + mydata1$gdp)
summary(m1)
# Code
ols_plot_resid_qq(m1)
ols_plot_resid_fit(m1)
ols_plot_resid_hist(m1)
# Code
residual <- resid(m1)
plot(fitted(m1), res)
abline(0,0)
plot(fitted(m1), residual)
abline(0,0)
plot(fitted(m1), residual)
abline(0,0)
ggplot(aes(x=resid)) + geom_histogram()
ggplot(aes(x=residual)) + geom_histogram()
ggplot(aes(x=as.data.frame(residual)) + geom_histogram()
plot(m1$residuals)
plot(m1$residuals)
m2 <- lm(mydata1$voteshare ~ mydata1$unemployment + mydata1$turnout + mydata1$transfers)
summary(m2)
mydata2 <- mydata1 %>% filter(party == "rad right")
View(mydata2)
ggplot(m1, aes(x=residuals)) + geom_histogram()
# Code
m1$residuals
# Code
hist(m1$residuals)
# Code
hist(m1$residuals, col="pink")
# Code
hist(m1$residuals, col="pink" #as you'll see a lot of grey better make it colourful)
# Code
#as you'll see a lot of grey better make it colourful
hist(m1$residuals, col="pink")
# Code
#as you'll see a lot of grey better make it colourful
hist(m1$residuals, col="pink")
# Code
AIC(m1, m2)
# Code
lm.full = lm(Price ~ ., data = mydata1)
# Code
lm.full = lm(voteshare ~ ., data = mydata1)
lm.step = step(lm.full, direction = "backward")
summary(lm.step)
lm.step = step(lm.full, direction = "forward")
summary(lm.step)
lm.step = step(lm.full, direction = "backward")
summary(lm.step)
AIC(lm.step)
summary(lm.step)
m3 <- lm(mydata2$voteshare ~ mydata2$emigration + mydata2$transfers + mydata2$gdp)
summary(m3)
mydata2_poland <- mydata2 %>% filter(country == "PL")
head(mydata2_poland)
m4 <- plm(voteshare ~ emigration + unemployment + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "random")
if (!require("plm")) install.packages("plm")
library(plm)
m4 <- plm(voteshare ~ emigration + unemployment + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "random")
summary(m4)
# Code
# panel data with fixed effects
fix <- plm(voteshare ~ emigration + unemployment + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "fixed")
# Code
# panel data with fixed effects
fix <- plm(voteshare ~ emigration + unemployment + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "within")
# data with random effects
random <- plm(voteshare ~ emigration + unemployment + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "random")
# Hausman test
phtest(fixed, random)
# Hausman test
phtest(fix, random)
m5 <- plm(voteshare ~ emigration + unemployment**2 + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "random")
summary(m5)
m5 <- plm(voteshare ~ emigration + unemployment**2 + transfers,
data = mydata1, index = c("country", "year"), model = "random")
2*sqrt(6/length(discoveries))
skewness(mydata1$voteshare)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 100)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 1)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(15)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 15)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 10)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 0.0001)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 0.01)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 0.001)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 0.05)
ggplot(mydata1, aes(x=voteshare)) + geom_histogram(binwidth = 0.04)
min(voteshare)
min(mydata1$voteshare)
max(mydata1$voteshare)
mean(mydata1$voteshare)
quantile(mydata1$voteshare, prob=.25)
quantile(mydata1$voteshare, prob=.75)
sd(mydata1$voteshare)
skewness(mydata1$voteshare)
2*sqrt(6/length(discoveries))
4*sqrt(6/length(UKDriverDeaths))
# Code
kurtosis(mydata1$voteshare)
# Hausman test
phtest(fix, m4)
summary(fix)
# Hausman test
phtest(fix, m4)
m5 <- plm(voteshare ~ emigration + unemployment**2 + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "within")
summary(m5)
m5 <- plm(voteshare ~ emigration + unemployment + unemployment**2 + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "within")
summary(m5)
m5 <- plm(voteshare ~ emigration + unemployment + I(unemployment**2) + transfers,
data = mydata2_poland, index = c("nuts", "year"), model = "within")
summary(m5)
plot(mydata2_poland$voteshare, mydata2_poland$unemployment)
plot(mydata2_poland$unemployment, mydata2_poland$voteshare)
2^64
if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/factoextra")
if(!require(FactoMineR)) install.packages("FactoMineR")
library(tidyverse)
movies <- readr::read_csv("https://www.warin.ca/datalake/courses_data/qmibr/session9/movies_metadata.csv")
movies_metadata <- read.csv("~/Desktop/MONTREAL/QM/movies_metadata.csv")
View(movies_metadata)
movies <- movies_metadata
df <- movies %>%
# select features
select(budget, popularity, revenue, runtime, vote_average, vote_count)
head(df)
library(dply)
library(dplyr)
library(dplyr)
install.packages("dplyr")
library(dplyr)
movies <- movies_metadata
df <- movies %>%
# select features
select(budget, popularity, revenue, runtime, vote_average, vote_count)
head(df)
library("FactoMineR")
res.pca <- PCA(df,  graph = FALSE)
df <- movies %>%
# select features
select(budget, popularity, revenue, runtime, vote_average, vote_count)
res.pca <- PCA(df,  graph = FALSE)
library(factoextra)
# Extract eigenvalues/variances
get_eig(res.pca)
res.pca <- PCA(df,  graph = FALSE)
head(df)
class(df)
type(df)
types(df)
summary(df)
as.numeric(df)
df$budget <- as.numeric(df$budget)
df$popularity <- as.numeric(df$popularity)
library("FactoMineR")
res.pca <- PCA(df,  graph = FALSE)
# Extract eigenvalues/variances
get_eig(res.pca)
# Visualize eigenvalues/variances
fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 50))
# Extract the results for variables
var <- get_pca_var(res.pca)
var
# Control variable colors using their contributions
fviz_pca_var(res.pca, col.var="contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE # Avoid text overlapping
)
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 10)
egg = 1.65
egg = 1.25
feed = 0.0025
plot(daily_egg_f) with kg = [0:150]
kg = [0:150]
kg = c(0:150)
plot(daily_egg_f)
daily_egg_f = 1+0,25*kg
daily_egg_f = 1+0.25*kg
plot(daily_egg_f)
grow_cost_f = 25*kg^2
plot(grow_cost_f)
feed_accumulation_f = daily_feed_f + daily_feed_f*day
daily_feed_f = staked_egg*4
egg/feed
feed/gg
feed/egg
feed_accumulation_f = daily_feed_f*(1+feed/egg)^day
staked_egg = 1
daily_egg_f = 1+0.25*kg
daily_feed_f = staked_egg*4
grow_cost_f = 25*kg^2
day = c(0:150)
feed_accumulation_f = daily_feed_f*(1+(4*feed/egg)^day
a
feed_accumulation_f = daily_feed_f*(1+(4*feed/egg))^day
plot(feed_accumulation_f)
head(feed_accumulation_f)
for i in [1:10]:
feed_day = []
feed_accumulation_f = 46.037*4
feed_accumulation_f = feed_accumulation_f + (feed_accumulation_f*egg/feed)*4
feed_day[i] = feed_accumulation_f
for i in [1:10]:
feed_day = []
#I try to create a function for the first scneario, in which all the feed is converted
#and the reinvested together with the daily egg yield
feed_day = ()
#I try to create a function for the first scneario, in which all the feed is converted
#and the reinvested together with the daily egg yield
feed_day = c(1:10)
for i in [1:10]:
feed_day = c(1:10)
feed_accumulation_f = 46.037*4
feed_accumulation_f = feed_accumulation_f + (feed_accumulation_f*egg/feed)*4
feed_day[i] = feed_accumulation_f
feed_day[i] = feed_accumulation_f}
#I try to create a function for the first scneario, in which all the feed is converted
#and the reinvested together with the daily egg yield
for (i in 1:10){feed_day = c(1:10)
feed_accumulation_f = 46.037*4
feed_accumulation_f = feed_accumulation_f + (feed_accumulation_f*egg/feed)*4
feed_day[i] = feed_accumulation_f
}
for (i in 1:10){feed_day = c(1:10)
feed_accumulation_f = 46.037*4
feed_accumulation_f = feed_accumulation_f + (feed_accumulation_f*feed/egg)*4
feed_day[i] = feed_accumulation_f
}
feed_day[1]
#I try to create a function for the first scneario, in which all the feed is converted
#and the reinvested together with the daily egg yield
feed_day = 46.037*4
for (i in 2:10){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]*feed/egg)*4
}
head(feed_day)
kg=12
daily_egg_f = 1+0.25*kg
daily_egg_f = 0.75+0.25*kg
feed_day = 46.037*4
for (i in 2:10){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]*feed/egg)*4 +daily_egg_f*4
}
head(feed_day)
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]/egg)*4 +daily_egg_f*4
feed_day = 46.037*4
for (i in 2:10){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]/egg)*4 +daily_egg_f*4
}
head(feed_day)
feed_day = 46.037*4
for (i in 2:10){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]*egg)*4 +daily_egg_f*4
}
head(feed_day)
for (i in 2:10){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]*(feed/egg))*4 +daily_egg_f*4
}
head(feed_day)
200*feed/egg
increase = feed_day[i] - feed_day[i-1]}
for (i in 2:10){
increase = feed_day[i] - feed_day[i-1]
}
for (i in 2:10){
increase[i] = feed_day[i] - feed_day[i-1]
}
head(increase)
46*4
184*feed
0.46/egg
0.368*4
1.368/46
feed_day = 46.037*4
for (i in 2:100){
feed_day[i]  = feed_day[i-1] + (feed_day[i-1]*(feed/egg))*4 +daily_egg_f*4
}
head(feed_day)
plot(feed_day)
feed_day[15]
feed_day[30]
feed_day[45]
install.packages("dplyr")
install.packages("tidyverse")
install.packages("dplyr")
install.packages("tidyverse")
